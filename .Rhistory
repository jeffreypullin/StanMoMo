death_sim_apc
gxt_apc
gxt_lc
phi_lc/(phi_lc+gxt)
post_mean_apc
post_mean_lc
phi_apc <- as.numeric(post_mean_apc %>% select('phi'))
phi_apc
names(apc_fit)
phi_apc/(phi_apc+gxt_apc)
gxt_lc/(gxt_lc+gxt)
gxt_lc/(phi_lc+gxt_lc)
death_sim_lc
death_sim_apc
phi_apc
phi_lc
# Test to see wether the true value of the paratmeter is within the psoterior distribution
lc_fit_sim <- lc_stan(death = death_sim_lc,exposure=death_sim_lc, validation=0,forecast = 1, family = "nb",chains=1,cores=4)
post_samples_sim <- as.data.frame(lc_fit_sim)
a_true <- t(post_mean_lc %>% select(starts_with('a[')))
b_true <- t(post_mean_lc %>% select(starts_with('b[')))
kt_true <-  t(post_mean_lc %>% select(starts_with('k[')))
phi_true <-  t(post_mean_lc %>% select(starts_with('phi')))
ages <- 50:90
years <- 1979:2008
ax_post = data.frame(a=double(), x = integer(), a_true = double())
for (k in 1:length(ages)){
ax_post = rbind(ax_post,
data.frame(a = as.numeric(t(post_samples_sim %>% select(paste0('a[',k,']')))), x = rep(ages[k],1000), a_true = rep(a_true[k],1000))
)
}
ggplot(data = ax_post) + geom_boxplot(mapping = aes(x = as.factor(x), y = a)) + geom_boxplot(mapping = aes(x = as.factor(x), y = a_true, color = 'red'))
a_true
ax_post = data.frame(a=double(), x = integer(), a_true = double())
for (k in 1:length(ages)){
ax_post = rbind(ax_post,
data.frame(a = as.numeric(t(post_samples_sim %>% select(paste0('a[',k,']')))), x = rep(ages[k],1000), a_true = rep(a_true[k],1000))
)
}
ax_post
# Test to see wether the true value of the paratmeter is within the psoterior distribution
lc_fit_sim <- lc_stan(death = death_sim_lc,exposure=exposureGBR, validation=0,forecast = 1, family = "nb",chains=1,cores=4)
post_samples_sim <- as.data.frame(lc_fit_sim)
a_true <- t(post_mean_lc %>% select(starts_with('a[')))
b_true <- t(post_mean_lc %>% select(starts_with('b[')))
kt_true <-  t(post_mean_lc %>% select(starts_with('k[')))
phi_true <-  t(post_mean_lc %>% select(starts_with('phi')))
ages <- 50:90
years <- 1979:2008
ax_post = data.frame(a=double(), x = integer(), a_true = double())
for (k in 1:length(ages)){
ax_post = rbind(ax_post,
data.frame(a = as.numeric(t(post_samples_sim %>% select(paste0('a[',k,']')))), x = rep(ages[k],1000), a_true = rep(a_true[k],1000))
)
}
ggplot(data = ax_post) + geom_boxplot(mapping = aes(x = as.factor(x), y = a)) + geom_boxplot(mapping = aes(x = as.factor(x), y = a_true, color = 'red'))
bx_post = data.frame(b=double(), x = integer(), b_true = double())
for (k in 1:length(ages)){
bx_post = rbind(bx_post,
data.frame(b = as.numeric(t(post_samples_sim %>% select(paste0('b[',k,']')))), x = rep(ages[k],1000), b_true = rep(b_true[k],1000))
)
}
ggplot(data = bx_post) + geom_boxplot(mapping = aes(x = as.factor(x), y = b)) + geom_boxplot(mapping = aes(x = as.factor(x), y = b_true, color = 'red'))
kt_post = data.frame(kt=double(), t = integer(), kt_true = double())
for(k in 1:length(years)){
kt_post = rbind(kt_post,
data.frame(kt = as.numeric(t(post_samples_sim %>% select(paste0('k[',k,']')))), t = rep(years[k],1000), kt_true = rep(kt_true[k],1000))
)
}
ggplot(data = kt_post) + geom_boxplot(mapping = aes(x = as.factor(t), y = kt)) + geom_boxplot(mapping = aes(x = as.factor(t), y = kt_true, color = 'red'))
phi_post = data.frame(phi = as.numeric(t(post_samples_sim %>% select('phi'))), phi_true = rep(phi_true,1000))
ggplot(data = phi_post) + geom_boxplot(mapping = aes(y = phi)) + geom_boxplot(mapping = aes(y = phi_true, color = 'red'))
for(i in 1:length(ages)){
for(j in 1:length(years)){
gxt_apc[i,j] <- exp(a_apc[i] + k_apc[j] + g_apc[match(years[j] - ages[i], cohorts)])*exposureGBR[i,j]
}
}
death_sim_apc <-  apply(gxt_apc, 1:2, function(gxt) rnbinom(1,size = phi_apc, prob = phi_apc/(phi_apc+gxt)))
death_sim_apc
death_sim_lc-death_sim_apc
apc_fit_sim <- apc_stan(death = death_sim_apc,exposure=exposureGBR, validation=0,forecast = 10, family = "nb",chains=1,cores=4)
post_samples_sim <- as.data.frame(apc_fit_sim)
a_true <- t(post_mean_apc %>% select(starts_with('a[')))
kt_true <-  t(post_mean_apc %>% select(starts_with('k[')))
g_true <-  t(post_mean_apc %>% select(starts_with('g[')))
phi_true <-  t(post_mean_apc %>% select(starts_with('phi')))
ages <- 50:90
years <- 1979:2008
phi_true
ax_post = data.frame(a=double(), x = integer(), a_true = double())
for (k in 1:length(ages)){
ax_post = rbind(ax_post,
data.frame(a = as.numeric(t(post_samples_sim %>% select(paste0('a[',k,']')))), x = rep(ages[k],1000), a_true = rep(a_true[k],1000))
)
}
ggplot(data = ax_post) + geom_boxplot(mapping = aes(x = as.factor(x), y = a)) + geom_boxplot(mapping = aes(x = as.factor(x), y = a_true, color = 'red'))
kt_post = data.frame(kt=double(), t = integer(), kt_true = double())
for(k in 1:length(years)){
kt_post = rbind(kt_post,
data.frame(kt = as.numeric(t(post_samples_sim %>% select(paste0('k[',k,']')))), t = rep(years[k],1000), kt_true = rep(kt_true[k],1000))
)
}
ggplot(data = kt_post) + geom_boxplot(mapping = aes(x = as.factor(t), y = kt)) + geom_boxplot(mapping = aes(x = as.factor(t), y = kt_true, color = 'red'))
g_post = data.frame(g=double(), t = integer(), g_true = double())
for(k in 1:length(cohorts)){
g_post = rbind(g_post,
data.frame(g = as.numeric(t(post_samples_sim %>% select(paste0('g[',k,']')))), co = rep(cohorts[k],1000), g_true = rep(g_true[k],1000))
)
}
ggplot(data = g_post) + geom_boxplot(mapping = aes(x = as.factor(co), y = g)) + geom_boxplot(mapping = aes(x = as.factor(co), y = g_true, color = 'red'))
phi_post = data.frame(phi = as.numeric(t(post_samples_sim %>% select('phi'))), phi_true = rep(phi_true,1000))
ggplot(data = phi_post) + geom_boxplot(mapping = aes(y = phi)) + geom_boxplot(mapping = aes(y = phi_true, color = 'red'))
# Test to see wether the true value of the true paratmeters are within the posterior distribution
lc_fit_sim <- lc_stan(death = death_sim_lc,exposure=exposureGBR, validation=0,forecast = 1, family = "nb",chains=1,cores=4)
# Test to see wether the true value of the true paratmeters are within the posterior distribution
apc_fit_sim <- apc_stan(death = death_sim_apc,exposure=exposureGBR, validation=0,forecast = 10, family = "nb",chains=1,cores=4)
library(StanMoMo)
library(tidyverse)
# library(ggplot2)
library(matrixcalc)
# library(purrr)
# help(load_HMD_data)
years <- 1979:2008
ages <- 50:90
cohorts <- sort(unique(as.vector(sapply(years, function(year) year - ages))))
deathGBR<-load_HMD_data('GBR_NP', 'Deaths_1x1', 1979:2008, 50:90, "Male")$mat
exposureGBR<-load_HMD_data('GBR_NP', 'Exposures_1x1', 1979:2008, 50:90, "Male")$mat
lc_fit <- lc_stan(death = deathGBR,exposure=exposureGBR, validation=0,forecast = 1, family = "nb",chains=1,cores=4)
apc_fit <- apc_stan(death = deathGBR,exposure=exposureGBR, validation=0,forecast = 10, family = "nb",chains=1,cores=4)
post_mean_lc <- as.data.frame(lc_fit) %>% select(starts_with('a['), starts_with('b['), starts_with('k['), 'phi') %>% summarise(across(everything(), mean))
post_mean_apc <- as.data.frame(apc_fit) %>% select(starts_with('a['), starts_with('g['), starts_with('k['), 'phi') %>% summarise(across(everything(), mean))
a_lc <- as.vector(t(post_mean_lc %>% select(starts_with('a['))))
b_lc <- as.vector(t(post_mean_lc %>% select(starts_with('b['))))
k_lc <- as.vector(t(post_mean_lc %>% select(starts_with('k['))))
phi_lc <- as.numeric(post_mean_lc %>% select('phi'))
a_apc <- as.vector(t(post_mean_apc %>% select(starts_with('a['))))
k_apc <- as.vector(t(post_mean_apc %>% select(starts_with('k['))))
g_apc <- as.vector(t(post_mean_apc %>% select(starts_with('g['))))
phi_apc <- as.numeric(post_mean_apc %>% select('phi'))
gxt_lc <- exp(sapply(k_lc, function(kt) a_lc + b_lc * kt))*exposureGBR[,1:length(years)]
colnames(exposureGBR)
rownames(exposureGBR)
years[1]-ages[1]
cohorts
gxt_apc <- 0*exposureGBR[,1:length(years)]
for(i in 1:length(ages)){
for(j in 1:length(years)){
gxt_apc[i,j] <- exp(a_apc[i] + k_apc[j] + g_apc[match(years[j] - ages[i], cohorts)])*exposureGBR[i,j]
}
}
# death_sim <- apply(lambda_mat,1:2, function(lam) rpois(1,lambda = lam))
# Negative binomial death count
death_sim_lc <- apply(gxt_lc, 1:2, function(gxt) rnbinom(1,size = phi_lc, prob = phi_lc/(phi_lc+gxt)))
death_sim_apc <-  apply(gxt_apc, 1:2, function(gxt) rnbinom(1,size = phi_apc, prob = phi_apc/(phi_apc+gxt)))
a_lc <- as.vector(t(post_mean_lc %>% select(starts_with('a['))))
b_lc <- as.vector(t(post_mean_lc %>% select(starts_with('b['))))
k_lc <- as.vector(t(post_mean_lc %>% select(starts_with('k['))))
phi_lc <- as.numeric(post_mean_lc %>% select('phi'))
a_apc <- as.vector(t(post_mean_apc %>% select(starts_with('a['))))
k_apc <- as.vector(t(post_mean_apc %>% select(starts_with('k['))))
g_apc <- as.vector(t(post_mean_apc %>% select(starts_with('g['))))
phi_apc <- as.numeric(post_mean_apc %>% select('phi'))
gxt_lc <- exp(sapply(k_lc, function(kt) a_lc + b_lc * kt))*exposureGBR[,1:length(years)]
gxt_apc <- 0*exposureGBR[,1:length(years)]
for(i in 1:length(ages)){
for(j in 1:length(years)){
gxt_apc[i,j] <- exp(a_apc[i] + k_apc[j] + g_apc[match(years[j] - ages[i], cohorts)])*exposureGBR[i,j]
}
}
# death_sim <- apply(lambda_mat,1:2, function(lam) rpois(1,lambda = lam))
# Negative binomial death count
death_sim_lc <- apply(gxt_lc, 1:2, function(gxt) rnbinom(1,size = phi_lc, prob = phi_lc/(phi_lc+gxt)))
death_sim_apc <-  apply(gxt_apc, 1:2, function(gxt) rnbinom(1,size = phi_apc, prob = phi_apc/(phi_apc+gxt)))
# Test to see wether the true value of the true paratmeters are within the posterior distribution
lc_fit_sim <- lc_stan(death = death_sim_lc,exposure=exposureGBR, validation=0,forecast = 1, family = "nb",chains=1,cores=4)
post_samples_sim <- as.data.frame(lc_fit_sim)
a_true <- t(post_mean_lc %>% select(starts_with('a[')))
b_true <- t(post_mean_lc %>% select(starts_with('b[')))
kt_true <-  t(post_mean_lc %>% select(starts_with('k[')))
phi_true <-  t(post_mean_lc %>% select(starts_with('phi')))
ages <- 50:90
years <- 1979:2008
ax_post = data.frame(a=double(), x = integer(), a_true = double())
for (k in 1:length(ages)){
ax_post = rbind(ax_post,
data.frame(a = as.numeric(t(post_samples_sim %>% select(paste0('a[',k,']')))), x = rep(ages[k],1000), a_true = rep(a_true[k],1000))
)
}
ggplot(data = ax_post) + geom_boxplot(mapping = aes(x = as.factor(x), y = a)) + geom_boxplot(mapping = aes(x = as.factor(x), y = a_true, color = 'red'))
bx_post = data.frame(b=double(), x = integer(), b_true = double())
for (k in 1:length(ages)){
bx_post = rbind(bx_post,
data.frame(b = as.numeric(t(post_samples_sim %>% select(paste0('b[',k,']')))), x = rep(ages[k],1000), b_true = rep(b_true[k],1000))
)
}
ggplot(data = bx_post) + geom_boxplot(mapping = aes(x = as.factor(x), y = b)) + geom_boxplot(mapping = aes(x = as.factor(x), y = b_true, color = 'red'))
kt_post = data.frame(kt=double(), t = integer(), kt_true = double())
for(k in 1:length(years)){
kt_post = rbind(kt_post,
data.frame(kt = as.numeric(t(post_samples_sim %>% select(paste0('k[',k,']')))), t = rep(years[k],1000), kt_true = rep(kt_true[k],1000))
)
}
ggplot(data = kt_post) + geom_boxplot(mapping = aes(x = as.factor(t), y = kt)) + geom_boxplot(mapping = aes(x = as.factor(t), y = kt_true, color = 'red'))
phi_post = data.frame(phi = as.numeric(t(post_samples_sim %>% select('phi'))), phi_true = rep(phi_true,1000))
ggplot(data = phi_post) + geom_boxplot(mapping = aes(y = phi)) + geom_boxplot(mapping = aes(y = phi_true, color = 'red'))
# Test to see wether the true value of the true paratmeters are within the posterior distribution
apc_fit_sim <- apc_stan(death = death_sim_apc,exposure=exposureGBR, validation=0,forecast = 10, family = "nb",chains=1,cores=4)
post_samples_sim <- as.data.frame(apc_fit_sim)
a_true <- t(post_mean_apc %>% select(starts_with('a[')))
kt_true <-  t(post_mean_apc %>% select(starts_with('k[')))
g_true <-  t(post_mean_apc %>% select(starts_with('g[')))
phi_true <-  t(post_mean_apc %>% select(starts_with('phi')))
ages <- 50:90
years <- 1979:2008
ax_post = data.frame(a=double(), x = integer(), a_true = double())
for (k in 1:length(ages)){
ax_post = rbind(ax_post,
data.frame(a = as.numeric(t(post_samples_sim %>% select(paste0('a[',k,']')))), x = rep(ages[k],1000), a_true = rep(a_true[k],1000))
)
}
ggplot(data = ax_post) + geom_boxplot(mapping = aes(x = as.factor(x), y = a)) + geom_boxplot(mapping = aes(x = as.factor(x), y = a_true, color = 'red'))
kt_post = data.frame(kt=double(), t = integer(), kt_true = double())
for(k in 1:length(years)){
kt_post = rbind(kt_post,
data.frame(kt = as.numeric(t(post_samples_sim %>% select(paste0('k[',k,']')))), t = rep(years[k],1000), kt_true = rep(kt_true[k],1000))
)
}
ggplot(data = kt_post) + geom_boxplot(mapping = aes(x = as.factor(t), y = kt)) + geom_boxplot(mapping = aes(x = as.factor(t), y = kt_true, color = 'red'))
g_post = data.frame(g=double(), t = integer(), g_true = double())
for(k in 1:length(cohorts)){
g_post = rbind(g_post,
data.frame(g = as.numeric(t(post_samples_sim %>% select(paste0('g[',k,']')))), co = rep(cohorts[k],1000), g_true = rep(g_true[k],1000))
)
}
ggplot(data = g_post) + geom_boxplot(mapping = aes(x = as.factor(co), y = g)) + geom_boxplot(mapping = aes(x = as.factor(co), y = g_true, color = 'red'))
phi_post = data.frame(phi = as.numeric(t(post_samples_sim %>% select('phi'))), phi_true = rep(phi_true,1000))
ggplot(data = phi_post) + geom_boxplot(mapping = aes(y = phi)) + geom_boxplot(mapping = aes(y = phi_true, color = 'red'))
library(parallel)
ages.fit<-50:90
samplingfunction<-function(x){
if (x==1) res<-lc_stan(death = death_sim_lc,exposure=exposureGBR, validation=10,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==2) res<-rh_stan(death = death_sim_lc,exposure=exposureGBR, validation=10,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==3) res<-apc_stan(death = death_sim_lc,exposure=exposureGBR, validation=10,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==4) res<-cbd_stan(death = death_sim_lc,exposure=exposureGBR, age=ages.fit,
validation=10,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==5) res<-m6_stan(death = death_sim_lc,exposure=exposureGBR, age=ages.fit,
validation=10,forecast = 10, family = "nb",chains=1,cores=1)
}
cl <- makeCluster(4)
clusterExport(cl,c('death_sim_lc','exposureGBR','ages.fit','lc_stan','rh_stan','apc_stan','cbd_stan','m6_stan'))
system.time({out <- parLapply(cl, c(1:5),samplingfunction)})
stopCluster(cl)
#Weights stacking Pseudo-BMA
model_weights<-mortality_weights(out)
print(model_weights)
library(parallel)
ages.fit<-50:90
samplingfunction<-function(x){
if (x==1) res<-lc_stan(death = death_sim_apc,exposure=exposureGBR, validation=10,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==2) res<-rh_stan(death = death_sim_apc,exposure=exposureGBR, validation=10,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==3) res<-apc_stan(death = death_sim_apc,exposure=exposureGBR, validation=10,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==4) res<-cbd_stan(death = death_sim_apc,exposure=exposureGBR, age=ages.fit,
validation=10,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==5) res<-m6_stan(death = death_sim_apc,exposure=exposureGBR, age=ages.fit,
validation=10,forecast = 10, family = "nb",chains=1,cores=1)
}
cl <- makeCluster(4)
clusterExport(cl,c('death_sim_apc','exposureGBR','ages.fit','lc_stan','rh_stan','apc_stan','cbd_stan','m6_stan'))
system.time({out <- parLapply(cl, c(1:5),samplingfunction)})
stopCluster(cl)
#Weights stacking Pseudo-BMA
model_weights_apc<-mortality_weights(out)
print(model_weights_apc)
#Data
validation=0
forecast=10
family="nb"
death<-death_sim_lc
exposure<-exposureGBR
age<-ages.fit
Tval<-0
if (validation !=0) Tval=validation
if (Tval==0) {
death1<-death
exposure1<-exposure
death2<-vector('integer')
exposure2<-vector('integer')
index<-seq(3,ncol(death1))
} else {
T<- ncol(death)-Tval
death1<-death[,1:T]
death2<-death[,(T+1):ncol(death)]
exposure1<-exposure[,1:T]
exposure2<-exposure[,(T+1):ncol(exposure)]
index<-seq(3,T)
}
family<-match.arg(family)
if (family == "poisson") {
family <- 0
} else if (family == "nb") {
family <- 1
}
standata<- list(J=nrow(death1),T=ncol(death1),
d=as.integer(as.vector(death1)),
e=as.integer(as.vector(exposure1)),
dval=as.integer(as.vector(death2)),
eval=as.integer(as.vector(exposure2)),
Tfor=forecast,Tval=Tval,
family=family,index=index)
validation=0
forecast=10
family="nb"
death<-deathFR
validation=0
forecast=10
family="nb"
death<-death_sim_lc
exposure<-exposureGBR
age<-ages.fit
Tval<-0
if (validation !=0) Tval=validation
if (Tval==0) {
death1<-death
exposure1<-exposure
death2<-vector('integer')
exposure2<-vector('integer')
index<-seq(2,ncol(death1))
} else {
T<- ncol(death)-Tval
death1<-death[,1:T]
death2<-death[,(T+1):ncol(death)]
exposure1<-exposure[,1:T]
exposure2<-exposure[,(T+1):ncol(exposure)]
index<-seq(2,T)
}
if (family == "poisson") {
family <- 0
} else if (family == "nb") {
family <- 1
}
standata2<- list(J=nrow(death1),T=ncol(death1),
d=as.integer(as.vector(death1)),
e=as.integer(as.vector(exposure1)),
age=age,
dval=as.integer(as.vector(death2)),
eval=as.integer(as.vector(exposure2)),
Tfor=forecast,Tval=Tval,
family=family,index=index)
#Bridgesampling
rstan_options(javascript = FALSE)
options(buildtools.check = function(action) TRUE )
library(rstan)
#Bridgesampling
rstan_options(javascript = FALSE)
options(buildtools.check = function(action) TRUE )
new_mod1 <- stan('leecarter.stan', data=standata,chains = 0)
new_mod1 <- stan('leecarter.stan', data=standata,chains = 0)
new_mod1 <- stan('leecarter.stan', data=standata,chains = 1)
bridge1 <- bridge_sampler(out[[1]], new_mod1,silent = TRUE)
install.packages("bridgesampling")
library(bridgesampling)
bridge1 <- bridge_sampler(out[[1]], new_mod1,silent = TRUE)
new_mod1 <- stan('leecarter.stan', data=standata,chains = 0)
bridge1 <- bridge_sampler(out[[1]], new_mod1,silent = TRUE)
print(bridge1)
if (validation !=0) Tval=validation
#Data
validation=0
family="nb"
death<-death_sim_lc
exposure<-exposureGBR
age<-ages.fit
Tval<-0
if (validation !=0) Tval=validation
if (Tval==0) {
death1<-death
exposure1<-exposure
death2<-vector('integer')
exposure2<-vector('integer')
index<-seq(3,ncol(death1))
} else {
T<- ncol(death)-Tval
death1<-death[,1:T]
death2<-death[,(T+1):ncol(death)]
exposure1<-exposure[,1:T]
exposure2<-exposure[,(T+1):ncol(exposure)]
index<-seq(3,T)
}
family<-match.arg(family)
if (family == "poisson") {
family <- 0
} else if (family == "nb") {
family <- 1
}
standata<- list(J=nrow(death1),T=ncol(death1),
d=as.integer(as.vector(death1)),
e=as.integer(as.vector(exposure1)),
dval=as.integer(as.vector(death2)),
eval=as.integer(as.vector(exposure2)),
Tfor=forecast,Tval=Tval,
family=family,index=index)
#For CBD and M6
validation=0
forecast=10
family="nb"
death<-death_sim_lc
exposure<-exposureGBR
age<-ages.fit
Tval<-0
if (validation !=0) Tval=validation
if (Tval==0) {
death1<-death
exposure1<-exposure
death2<-vector('integer')
exposure2<-vector('integer')
index<-seq(2,ncol(death1))
} else {
T<- ncol(death)-Tval
death1<-death[,1:T]
death2<-death[,(T+1):ncol(death)]
exposure1<-exposure[,1:T]
exposure2<-exposure[,(T+1):ncol(exposure)]
index<-seq(2,T)
}
family<-match.arg(family)
if (family == "poisson") {
family <- 0
} else if (family == "nb") {
family <- 1
}
standata2<- list(J=nrow(death1),T=ncol(death1),
d=as.integer(as.vector(death1)),
e=as.integer(as.vector(exposure1)),
age=age,
dval=as.integer(as.vector(death2)),
eval=as.integer(as.vector(exposure2)),
Tfor=forecast,Tval=Tval,
family=family,index=index)
library(rstan)
library(bridgesampling)
#Bridgesampling
rstan_options(javascript = FALSE)
options(buildtools.check = function(action) TRUE )
new_mod1 <- stan('leecarter.stan', data=standata,chains = 0)
out[[1]]
bridge1 <- bridge_sampler(out[[1]], new_mod1,silent = TRUE)
ncol(death1)
nrow(death1)
deathFR
deathFR<-load_HMD_data('GBR_NP', 'Deaths_1x1', 1979:2008, 50:90, "Male")$mat
exposureFR<-load_HMD_data('GBR_NP', 'Exposures_1x1', 1979:2008, 50:90, "Male")$mat
validation=0
forecast=10
family="nb"
death<-deathFR
exposure<-exposureFR
age<-ages.fit
age
Tval<-0
if (validation !=0) Tval=validation
if (Tval==0) {
death1<-death
exposure1<-exposure
death2<-vector('integer')
exposure2<-vector('integer')
index<-seq(2,ncol(death1))
} else {
T<- ncol(death)-Tval
death1<-death[,1:T]
death2<-death[,(T+1):ncol(death)]
exposure1<-exposure[,1:T]
exposure2<-exposure[,(T+1):ncol(exposure)]
index<-seq(2,T)
}
family<-match.arg(family)
if (family == "poisson") {
family <- 0
} else if (family == "nb") {
family <- 1
}
standata2<- list(J=nrow(death1),T=ncol(death1),
d=as.integer(as.vector(death1)),
e=as.integer(as.vector(exposure1)),
age=age,
dval=as.integer(as.vector(death2)),
eval=as.integer(as.vector(exposure2)),
Tfor=forecast,Tval=Tval,
family=family,index=index)
rstan_options(javascript = FALSE)
options(buildtools.check = function(action) TRUE )
new_mod1 <- stan('leecarter.stan', data=standata,chains = 0)
bridge1 <- bridge_sampler(out[[1]], new_mod1,silent = TRUE)
new_mod1 <- stan('leecarter.stan', data=standata,chains = 0)
new_mod1
new_mod1
bridge1 <- bridge_sampler(out[[1]], new_mod1,silent = TRUE)
out[[1]]
out
print(model_weights_apc)
print(model_weights_lc)
samplingfunction<-function(x){
if (x==1) res<-lc_stan(death = death_sim_lc,exposure=exposureGBR, validation=0,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==2) res<-rh_stan(death = death_sim_lc,exposure=exposureGBR, validation=0,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==3) res<-apc_stan(death = death_sim_lc,exposure=exposureGBR, validation=0,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==4) res<-cbd_stan(death = death_sim_lc,exposure=exposureGBR, age=ages.fit,
validation=0,forecast = 10, family = "nb",chains=1,cores=1)
else if (x==5) res<-m6_stan(death = death_sim_lc,exposure=exposureGBR, age=ages.fit,
validation=0,forecast = 10, family = "nb",chains=1,cores=1)
}
cl <- makeCluster(4)
clusterExport(cl,c('death_sim_lc','exposureGBR','ages.fit','lc_stan','rh_stan','apc_stan','cbd_stan','m6_stan'))
system.time({out <- parLapply(cl, c(1:5),samplingfunction)})
